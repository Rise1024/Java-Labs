---
title: Javaè®¾è®¡æ¨¡å¼å®æˆ˜ï¼šè¡Œä¸ºå‹æ¨¡å¼æ·±åº¦è§£æ
description: æ·±å…¥è§£æJavaè¡Œä¸ºå‹è®¾è®¡æ¨¡å¼ï¼ŒåŒ…æ‹¬è§‚å¯Ÿè€…ã€ç­–ç•¥ã€å‘½ä»¤ç­‰æ¨¡å¼çš„å®ç°åŸç†å’Œæœ€ä½³å®è·µ
tags: [Java, è®¾è®¡æ¨¡å¼, è¡Œä¸ºå‹æ¨¡å¼, è§‚å¯Ÿè€…æ¨¡å¼, ç­–ç•¥æ¨¡å¼, å‘½ä»¤æ¨¡å¼]
category: è®¾è®¡æ¨¡å¼
date: 2025-09-26
---

# Javaè®¾è®¡æ¨¡å¼å®æˆ˜ï¼šè¡Œä¸ºå‹æ¨¡å¼æ·±åº¦è§£æ

## ğŸ¯ å¼•è¨€

è¡Œä¸ºå‹æ¨¡å¼å…³æ³¨å¯¹è±¡ä¹‹é—´çš„é€šä¿¡ï¼Œæè¿°å¯¹è±¡ä¹‹é—´å¦‚ä½•äº¤äº’å’Œå¦‚ä½•åˆ†é…èŒè´£ã€‚è¿™äº›æ¨¡å¼ä¸ä»…å…³æ³¨å¯¹è±¡çš„ç»“æ„ï¼Œæ›´å…³æ³¨å¯¹è±¡ä¹‹é—´çš„äº¤äº’æµç¨‹å’Œç®—æ³•çš„åˆ†é…ã€‚

æœ¬æ–‡å°†æ·±å…¥è§£ææœ€é‡è¦çš„è¡Œä¸ºå‹è®¾è®¡æ¨¡å¼ï¼Œç»“åˆç°ä»£Javaç‰¹æ€§å’Œä¼ä¸šçº§å¼€å‘å®è·µï¼Œæä¾›å¯ç›´æ¥åº”ç”¨çš„è§£å†³æ–¹æ¡ˆã€‚

## ğŸ“š è¡Œä¸ºå‹æ¨¡å¼æ¦‚è¿°

è¡Œä¸ºå‹æ¨¡å¼ä¸»è¦è§£å†³ä»¥ä¸‹é—®é¢˜ï¼š
- **ç®—æ³•å˜åŒ–** - å°è£…ç®—æ³•ï¼Œä½¿ç®—æ³•å¯ä»¥ç‹¬ç«‹äºä½¿ç”¨å®ƒçš„å®¢æˆ·ç«¯å˜åŒ–
- **å¯¹è±¡äº¤äº’** - å®šä¹‰å¯¹è±¡é—´çš„äº¤äº’æ–¹å¼å’ŒèŒè´£åˆ†é…
- **çŠ¶æ€ç®¡ç†** - ç®¡ç†å¯¹è±¡çŠ¶æ€å˜åŒ–å’ŒçŠ¶æ€è½¬æ¢
- **è¯·æ±‚å¤„ç†** - è§„èŒƒè¯·æ±‚çš„å‘é€å’Œå¤„ç†æµç¨‹

### è¡Œä¸ºå‹æ¨¡å¼åˆ†ç±»

| æ¨¡å¼åç§° | ä¸»è¦ç›®çš„ | é€‚ç”¨åœºæ™¯ | å¤æ‚åº¦ |
|---------|---------|---------|-------|
| **è§‚å¯Ÿè€…æ¨¡å¼** | ä¸€å¯¹å¤šä¾èµ–å…³ç³» | äº‹ä»¶é€šçŸ¥ã€MVCæ¶æ„ | â­â­â­ |
| **ç­–ç•¥æ¨¡å¼** | ç®—æ³•æ—å°è£… | ç®—æ³•å˜åŒ–ã€æ”¯ä»˜æ–¹å¼é€‰æ‹© | â­â­â­ |
| **å‘½ä»¤æ¨¡å¼** | è¯·æ±‚å°è£… | æ’¤é”€æ“ä½œã€é˜Ÿåˆ—å¤„ç† | â­â­â­â­ |
| **æ¨¡æ¿æ–¹æ³•æ¨¡å¼** | ç®—æ³•éª¨æ¶å®šä¹‰ | æ¡†æ¶è®¾è®¡ã€æµç¨‹æ§åˆ¶ | â­â­â­ |
| **è´£ä»»é“¾æ¨¡å¼** | è¯·æ±‚ä¼ é€’é“¾ | è¿‡æ»¤å™¨ã€ä¸­é—´ä»¶ | â­â­â­â­ |
| **çŠ¶æ€æ¨¡å¼** | çŠ¶æ€è½¬æ¢ | çŠ¶æ€æœºã€å·¥ä½œæµ | â­â­â­â­â­ |
| **è®¿é—®è€…æ¨¡å¼** | æ“ä½œä¸ç»“æ„åˆ†ç¦» | ç¼–è¯‘å™¨ã€ASTå¤„ç† | â­â­â­â­â­ |
| **ä¸­ä»‹è€…æ¨¡å¼** | å¯¹è±¡é—´äº¤äº’ | ç»„ä»¶é€šä¿¡ã€èŠå¤©å®¤ | â­â­â­â­ |
| **å¤‡å¿˜å½•æ¨¡å¼** | çŠ¶æ€ä¿å­˜æ¢å¤ | æ’¤é”€åŠŸèƒ½ã€å¿«ç…§ | â­â­â­ |
| **è¿­ä»£å™¨æ¨¡å¼** | é›†åˆéå† | æ•°æ®ç»“æ„éå† | â­â­ |
| **è§£é‡Šå™¨æ¨¡å¼** | è¯­è¨€è§£é‡Š | DSLã€è¡¨è¾¾å¼è§£æ | â­â­â­â­â­ |

## ğŸ‘€ è§‚å¯Ÿè€…æ¨¡å¼è¯¦è§£

### æ¨¡å¼å®šä¹‰

å®šä¹‰å¯¹è±¡é—´çš„ä¸€ç§ä¸€å¯¹å¤šçš„ä¾èµ–å…³ç³»ï¼Œå½“ä¸€ä¸ªå¯¹è±¡çš„çŠ¶æ€å‘ç”Ÿæ”¹å˜æ—¶ï¼Œæ‰€æœ‰ä¾èµ–äºå®ƒçš„å¯¹è±¡éƒ½å¾—åˆ°é€šçŸ¥å¹¶è¢«è‡ªåŠ¨æ›´æ–°ã€‚

### ä¼ ç»Ÿå®ç°

```java
// è§‚å¯Ÿè€…æ¥å£
public interface Observer {
    void update(String message);
    String getName();
}

// ä¸»é¢˜æ¥å£
public interface Subject {
    void addObserver(Observer observer);
    void removeObserver(Observer observer);
    void notifyObservers(String message);
}

// å…·ä½“ä¸»é¢˜ - æ–°é—»å‘å¸ƒè€…
@Slf4j
public class ConcreteSubject implements Subject {
    private final List<Observer> observers = new ArrayList<>();
    private String state;
    
    @Override
    public void addObserver(Observer observer) {
        observers.add(observer);
        log.info("æ·»åŠ è§‚å¯Ÿè€…: {}", observer.getName());
    }
    
    @Override
    public void removeObserver(Observer observer) {
        observers.remove(observer);
        log.info("ç§»é™¤è§‚å¯Ÿè€…: {}", observer.getName());
    }
    
    @Override
    public void notifyObservers(String message) {
        log.info("é€šçŸ¥ {} ä¸ªè§‚å¯Ÿè€…: {}", observers.size(), message);
        for (Observer observer : observers) {
            observer.update(message);
        }
    }
    
    public void setState(String state) {
        this.state = state;
        log.info("ä¸»é¢˜çŠ¶æ€æ”¹å˜: {}", state);
        notifyObservers(state);
    }
}

// å…·ä½“è§‚å¯Ÿè€…
@Slf4j
@AllArgsConstructor
@Getter
public class ConcreteObserver implements Observer {
    private final String name;
    
    @Override
    public void update(String message) {
        log.info("è§‚å¯Ÿè€… [{}] æ”¶åˆ°æ›´æ–°: {}", name, message);
        processMessage(message);
    }
    
    private void processMessage(String message) {
        log.info("è§‚å¯Ÿè€… [{}] å¤„ç†æ¶ˆæ¯: {}", name, message);
    }
}
```

### ç°ä»£Javaå®ç° - ä½¿ç”¨å‡½æ•°å¼æ¥å£

```java
// ä½¿ç”¨Consumeræ¥å£ç®€åŒ–è§‚å¯Ÿè€…
@Slf4j
public class ModernObservable {
    private final List<Consumer<String>> observers = new CopyOnWriteArrayList<>();
    
    public void subscribe(Consumer<String> observer) {
        observers.add(observer);
        log.info("æ·»åŠ è§‚å¯Ÿè€…ï¼Œå½“å‰æ€»æ•°: {}", observers.size());
    }
    
    public void unsubscribe(Consumer<String> observer) {
        observers.remove(observer);
        log.info("ç§»é™¤è§‚å¯Ÿè€…ï¼Œå½“å‰æ€»æ•°: {}", observers.size());
    }
    
    public void publish(String message) {
        log.info("å‘å¸ƒæ¶ˆæ¯: {}", message);
        observers.forEach(observer -> {
            try {
                observer.accept(message);
            } catch (Exception e) {
                log.error("è§‚å¯Ÿè€…å¤„ç†æ¶ˆæ¯æ—¶å‘ç”Ÿé”™è¯¯", e);
            }
        });
    }
}

// ä½¿ç”¨ç¤ºä¾‹
public class ModernObserverDemo {
    public static void main(String[] args) {
        ModernObservable observable = new ModernObservable();
        
        // è®¢é˜…è§‚å¯Ÿè€…
        observable.subscribe(message -> 
            System.out.println("é‚®ä»¶é€šçŸ¥: " + message));
        observable.subscribe(message -> 
            System.out.println("çŸ­ä¿¡é€šçŸ¥: " + message));
        observable.subscribe(message -> 
            System.out.println("æ¨é€é€šçŸ¥: " + message));
        
        // å‘å¸ƒæ¶ˆæ¯
        observable.publish("ç”¨æˆ·æ³¨å†ŒæˆåŠŸ");
    }
}
```

### ä¼ä¸šçº§åº”ç”¨ - äº‹ä»¶é©±åŠ¨æ¶æ„

```java
// äº‹ä»¶åŸºç±»
@Getter
@AllArgsConstructor
public abstract class DomainEvent {
    private final String eventId;
    private final LocalDateTime timestamp;
    private final String eventType;
    
    public DomainEvent(String eventType) {
        this.eventId = UUID.randomUUID().toString();
        this.timestamp = LocalDateTime.now();
        this.eventType = eventType;
    }
}

// ç”¨æˆ·æ³¨å†Œäº‹ä»¶
@Getter
public class UserRegisteredEvent extends DomainEvent {
    private final String userId;
    private final String email;
    private final String username;
    
    public UserRegisteredEvent(String userId, String email, String username) {
        super("USER_REGISTERED");
        this.userId = userId;
        this.email = email;
        this.username = username;
    }
}

// äº‹ä»¶å¤„ç†å™¨æ¥å£
@FunctionalInterface
public interface EventHandler<T extends DomainEvent> {
    void handle(T event);
}

// äº‹ä»¶æ€»çº¿
@Slf4j
@Component
public class EventBus {
    private final Map<Class<? extends DomainEvent>, List<EventHandler<? extends DomainEvent>>> 
        handlers = new ConcurrentHashMap<>();
    
    @SuppressWarnings("unchecked")
    public <T extends DomainEvent> void subscribe(Class<T> eventType, 
                                                  EventHandler<T> handler) {
        handlers.computeIfAbsent(eventType, k -> new CopyOnWriteArrayList<>())
                .add(handler);
        log.info("æ³¨å†Œäº‹ä»¶å¤„ç†å™¨: {} -> {}", eventType.getSimpleName(), 
                handler.getClass().getSimpleName());
    }
    
    @SuppressWarnings("unchecked")
    public void publish(DomainEvent event) {
        log.info("å‘å¸ƒäº‹ä»¶: {} [{}]", event.getEventType(), event.getEventId());
        
        List<EventHandler<? extends DomainEvent>> eventHandlers = 
            handlers.get(event.getClass());
        
        if (eventHandlers != null) {
            eventHandlers.forEach(handler -> {
                try {
                    ((EventHandler<DomainEvent>) handler).handle(event);
                } catch (Exception e) {
                    log.error("äº‹ä»¶å¤„ç†å¤±è´¥: {}", event.getEventId(), e);
                }
            });
        }
    }
}

// äº‹ä»¶å¤„ç†å™¨å®ç°
@Component
@Slf4j
public class UserEventHandlers {
    
    @EventHandler
    public void handleUserRegistered(UserRegisteredEvent event) {
        log.info("å¤„ç†ç”¨æˆ·æ³¨å†Œäº‹ä»¶: {}", event.getUserId());
        
        // å‘é€æ¬¢è¿é‚®ä»¶
        sendWelcomeEmail(event.getEmail(), event.getUsername());
        
        // åˆ›å»ºç”¨æˆ·é…ç½®æ–‡ä»¶
        createUserProfile(event.getUserId());
        
        // å‘é€ç»Ÿè®¡æ•°æ®
        updateRegistrationStatistics();
    }
    
    private void sendWelcomeEmail(String email, String username) {
        log.info("å‘é€æ¬¢è¿é‚®ä»¶åˆ°: {}", email);
    }
    
    private void createUserProfile(String userId) {
        log.info("ä¸ºç”¨æˆ·åˆ›å»ºé…ç½®æ–‡ä»¶: {}", userId);
    }
    
    private void updateRegistrationStatistics() {
        log.info("æ›´æ–°æ³¨å†Œç»Ÿè®¡æ•°æ®");
    }
}
```

## ğŸ¯ ç­–ç•¥æ¨¡å¼è¯¦è§£

### æ¨¡å¼å®šä¹‰

å®šä¹‰ä¸€ç³»åˆ—ç®—æ³•ï¼ŒæŠŠå®ƒä»¬ä¸€ä¸ªä¸ªå°è£…èµ·æ¥ï¼Œå¹¶ä¸”ä½¿å®ƒä»¬å¯ç›¸äº’æ›¿æ¢ã€‚ç­–ç•¥æ¨¡å¼ä½¿å¾—ç®—æ³•å¯ç‹¬ç«‹äºä½¿ç”¨å®ƒçš„å®¢æˆ·ç«¯è€Œå˜åŒ–ã€‚

### æ ¸å¿ƒå®ç°

```java
// ç­–ç•¥æ¥å£
public interface Strategy {
    int execute(int a, int b);
    String getName();
}

// å…·ä½“ç­–ç•¥å®ç°
@Slf4j
public class AddStrategy implements Strategy {
    @Override
    public int execute(int a, int b) {
        int result = a + b;
        log.info("æ‰§è¡ŒåŠ æ³•ç­–ç•¥: {} + {} = {}", a, b, result);
        return result;
    }
    
    @Override
    public String getName() {
        return "åŠ æ³•ç­–ç•¥";
    }
}

@Slf4j
public class MultiplyStrategy implements Strategy {
    @Override
    public int execute(int a, int b) {
        int result = a * b;
        log.info("æ‰§è¡Œä¹˜æ³•ç­–ç•¥: {} * {} = {}", a, b, result);
        return result;
    }
    
    @Override
    public String getName() {
        return "ä¹˜æ³•ç­–ç•¥";
    }
}

// ä¸Šä¸‹æ–‡ç±»
@Slf4j
@AllArgsConstructor
public class Context {
    private Strategy strategy;
    
    public void setStrategy(Strategy strategy) {
        this.strategy = strategy;
        log.info("åˆ‡æ¢ç­–ç•¥: {}", strategy.getName());
    }
    
    public int executeStrategy(int a, int b) {
        if (strategy == null) {
            throw new IllegalStateException("ç­–ç•¥æœªè®¾ç½®");
        }
        
        log.info("ä½¿ç”¨ç­–ç•¥ [{}] æ‰§è¡Œè®¡ç®—", strategy.getName());
        return strategy.execute(a, b);
    }
}
```

### ç°ä»£Javaå®ç° - ä½¿ç”¨æšä¸¾å’Œå‡½æ•°å¼æ¥å£

```java
// ä½¿ç”¨æšä¸¾å®ç°ç­–ç•¥æ¨¡å¼
public enum CalculationStrategy {
    ADD((a, b) -> a + b, "åŠ æ³•"),
    SUBTRACT((a, b) -> a - b, "å‡æ³•"),
    MULTIPLY((a, b) -> a * b, "ä¹˜æ³•"),
    DIVIDE((a, b) -> {
        if (b == 0) throw new ArithmeticException("é™¤æ•°ä¸èƒ½ä¸ºé›¶");
        return a / b;
    }, "é™¤æ³•");
    
    private final BinaryOperator<Integer> operation;
    private final String description;
    
    CalculationStrategy(BinaryOperator<Integer> operation, String description) {
        this.operation = operation;
        this.description = description;
    }
    
    public int calculate(int a, int b) {
        return operation.apply(a, b);
    }
    
    public String getDescription() {
        return description;
    }
}

// ç°ä»£è®¡ç®—å™¨
@Slf4j
public class ModernCalculator {
    
    public int calculate(int a, int b, CalculationStrategy strategy) {
        log.info("ä½¿ç”¨ {} è®¡ç®—: {} å’Œ {}", strategy.getDescription(), a, b);
        int result = strategy.calculate(a, b);
        log.info("è®¡ç®—ç»“æœ: {}", result);
        return result;
    }
    
    // æ”¯æŒåŠ¨æ€ç­–ç•¥é€‰æ‹©
    public int calculate(int a, int b, String operation) {
        CalculationStrategy strategy = switch (operation.toUpperCase()) {
            case "ADD", "+" -> CalculationStrategy.ADD;
            case "SUBTRACT", "-" -> CalculationStrategy.SUBTRACT;
            case "MULTIPLY", "*" -> CalculationStrategy.MULTIPLY;
            case "DIVIDE", "/" -> CalculationStrategy.DIVIDE;
            default -> throw new IllegalArgumentException("ä¸æ”¯æŒçš„è¿ç®—: " + operation);
        };
        
        return calculate(a, b, strategy);
    }
}
```

### ä¼ä¸šçº§åº”ç”¨ - æ”¯ä»˜ç­–ç•¥

```java
// æ”¯ä»˜ç»“æœ
@Getter
@AllArgsConstructor
public class PaymentResult {
    private final boolean success;
    private final String message;
    private final String transactionId;
}

// æ”¯ä»˜ç­–ç•¥æ¥å£
public interface PaymentStrategy {
    PaymentResult processPayment(double amount, String currency);
    String getPaymentMethod();
    boolean isAvailable();
}

// å…·ä½“æ”¯ä»˜ç­–ç•¥
@Slf4j
@Component
public class CreditCardPaymentStrategy implements PaymentStrategy {
    
    @Override
    public PaymentResult processPayment(double amount, String currency) {
        log.info("å¤„ç†ä¿¡ç”¨å¡æ”¯ä»˜: {} {}", amount, currency);
        
        // æ¨¡æ‹Ÿä¿¡ç”¨å¡æ”¯ä»˜é€»è¾‘
        if (amount > 10000) {
            return new PaymentResult(false, "è¶…è¿‡ä¿¡ç”¨å¡é™é¢", null);
        }
        
        String transactionId = "CC-" + UUID.randomUUID().toString();
        log.info("ä¿¡ç”¨å¡æ”¯ä»˜æˆåŠŸï¼Œäº¤æ˜“ID: {}", transactionId);
        
        return new PaymentResult(true, "æ”¯ä»˜æˆåŠŸ", transactionId);
    }
    
    @Override
    public String getPaymentMethod() {
        return "ä¿¡ç”¨å¡";
    }
    
    @Override
    public boolean isAvailable() {
        return true; // æ£€æŸ¥ä¿¡ç”¨å¡æœåŠ¡æ˜¯å¦å¯ç”¨
    }
}

@Slf4j
@Component
public class DigitalWalletPaymentStrategy implements PaymentStrategy {
    
    @Override
    public PaymentResult processPayment(double amount, String currency) {
        log.info("å¤„ç†æ•°å­—é’±åŒ…æ”¯ä»˜: {} {}", amount, currency);
        
        // æ¨¡æ‹Ÿæ•°å­—é’±åŒ…æ”¯ä»˜é€»è¾‘
        if (!checkBalance(amount)) {
            return new PaymentResult(false, "æ•°å­—é’±åŒ…ä½™é¢ä¸è¶³", null);
        }
        
        String transactionId = "DW-" + UUID.randomUUID().toString();
        log.info("æ•°å­—é’±åŒ…æ”¯ä»˜æˆåŠŸï¼Œäº¤æ˜“ID: {}", transactionId);
        
        return new PaymentResult(true, "æ”¯ä»˜æˆåŠŸ", transactionId);
    }
    
    private boolean checkBalance(double amount) {
        // æ£€æŸ¥é’±åŒ…ä½™é¢
        return amount <= 5000; // æ¨¡æ‹Ÿä½™é¢é™åˆ¶
    }
    
    @Override
    public String getPaymentMethod() {
        return "æ•°å­—é’±åŒ…";
    }
    
    @Override
    public boolean isAvailable() {
        return true; // æ£€æŸ¥æ•°å­—é’±åŒ…æœåŠ¡æ˜¯å¦å¯ç”¨
    }
}

// æ”¯ä»˜æœåŠ¡
@Service
@Slf4j
public class PaymentService {
    private final Map<String, PaymentStrategy> strategies;
    
    public PaymentService(List<PaymentStrategy> strategies) {
        this.strategies = strategies.stream()
                .collect(Collectors.toMap(
                    PaymentStrategy::getPaymentMethod,
                    Function.identity()
                ));
    }
    
    public PaymentResult processPayment(double amount, String currency, 
                                      String paymentMethod) {
        PaymentStrategy strategy = strategies.get(paymentMethod);
        
        if (strategy == null) {
            return new PaymentResult(false, 
                "ä¸æ”¯æŒçš„æ”¯ä»˜æ–¹å¼: " + paymentMethod, null);
        }
        
        if (!strategy.isAvailable()) {
            return new PaymentResult(false, 
                paymentMethod + " æœåŠ¡æš‚æ—¶ä¸å¯ç”¨", null);
        }
        
        log.info("å¼€å§‹å¤„ç†æ”¯ä»˜: {} {} ä½¿ç”¨ {}", amount, currency, paymentMethod);
        
        try {
            return strategy.processPayment(amount, currency);
        } catch (Exception e) {
            log.error("æ”¯ä»˜å¤„ç†å¤±è´¥", e);
            return new PaymentResult(false, "æ”¯ä»˜å¤„ç†å¤±è´¥: " + e.getMessage(), null);
        }
    }
    
    public List<String> getAvailablePaymentMethods() {
        return strategies.values().stream()
                .filter(PaymentStrategy::isAvailable)
                .map(PaymentStrategy::getPaymentMethod)
                .collect(Collectors.toList());
    }
}
```

## ğŸ“ å‘½ä»¤æ¨¡å¼è¯¦è§£

### æ¨¡å¼å®šä¹‰

å°†ä¸€ä¸ªè¯·æ±‚å°è£…ä¸ºä¸€ä¸ªå¯¹è±¡ï¼Œä»è€Œå¯ä»¥ç”¨ä¸åŒçš„è¯·æ±‚å¯¹å®¢æˆ·è¿›è¡Œå‚æ•°åŒ–ï¼Œå¯¹è¯·æ±‚æ’é˜Ÿæˆ–è®°å½•è¯·æ±‚æ—¥å¿—ï¼Œä»¥åŠæ”¯æŒå¯æ’¤é”€çš„æ“ä½œã€‚

### æ ¸å¿ƒå®ç°

```java
// å‘½ä»¤æ¥å£
public interface Command {
    void execute();
    void undo();
    String getDescription();
}

// æ¥æ”¶è€… - æ–‡æœ¬ç¼–è¾‘å™¨
@Slf4j
public class TextEditor {
    private StringBuilder content = new StringBuilder();
    
    public void insertText(String text) {
        content.append(text);
        log.info("æ’å…¥æ–‡æœ¬: '{}', å½“å‰å†…å®¹: '{}'", text, content);
    }
    
    public void deleteText(int length) {
        if (length > content.length()) {
            length = content.length();
        }
        content.delete(content.length() - length, content.length());
        log.info("åˆ é™¤ {} ä¸ªå­—ç¬¦, å½“å‰å†…å®¹: '{}'", length, content);
    }
    
    public String getContent() {
        return content.toString();
    }
    
    public void setContent(String content) {
        this.content = new StringBuilder(content);
        log.info("è®¾ç½®å†…å®¹: '{}'", content);
    }
}

// å…·ä½“å‘½ä»¤ - æ’å…¥æ–‡æœ¬å‘½ä»¤
@AllArgsConstructor
public class InsertTextCommand implements Command {
    private final TextEditor editor;
    private final String text;
    
    @Override
    public void execute() {
        editor.insertText(text);
    }
    
    @Override
    public void undo() {
        editor.deleteText(text.length());
    }
    
    @Override
    public String getDescription() {
        return "æ’å…¥æ–‡æœ¬: " + text;
    }
}

// å…·ä½“å‘½ä»¤ - åˆ é™¤æ–‡æœ¬å‘½ä»¤
@AllArgsConstructor
public class DeleteTextCommand implements Command {
    private final TextEditor editor;
    private final int length;
    private String deletedText = "";
    
    @Override
    public void execute() {
        String content = editor.getContent();
        int deleteStart = Math.max(0, content.length() - length);
        deletedText = content.substring(deleteStart);
        editor.deleteText(length);
    }
    
    @Override
    public void undo() {
        editor.insertText(deletedText);
    }
    
    @Override
    public String getDescription() {
        return "åˆ é™¤ " + length + " ä¸ªå­—ç¬¦";
    }
}

// è°ƒç”¨è€… - ç¼–è¾‘å™¨æ§åˆ¶å™¨
@Slf4j
public class EditorController {
    private final Stack<Command> history = new Stack<>();
    private final Stack<Command> redoStack = new Stack<>();
    
    public void executeCommand(Command command) {
        command.execute();
        history.push(command);
        redoStack.clear(); // æ‰§è¡Œæ–°å‘½ä»¤æ—¶æ¸…ç©ºé‡åšæ ˆ
        log.info("æ‰§è¡Œå‘½ä»¤: {}", command.getDescription());
    }
    
    public void undo() {
        if (!history.isEmpty()) {
            Command command = history.pop();
            command.undo();
            redoStack.push(command);
            log.info("æ’¤é”€å‘½ä»¤: {}", command.getDescription());
        } else {
            log.info("æ²¡æœ‰å¯æ’¤é”€çš„å‘½ä»¤");
        }
    }
    
    public void redo() {
        if (!redoStack.isEmpty()) {
            Command command = redoStack.pop();
            command.execute();
            history.push(command);
            log.info("é‡åšå‘½ä»¤: {}", command.getDescription());
        } else {
            log.info("æ²¡æœ‰å¯é‡åšçš„å‘½ä»¤");
        }
    }
    
    public void showHistory() {
        log.info("å‘½ä»¤å†å² ({} ä¸ªå‘½ä»¤):", history.size());
        for (int i = 0; i < history.size(); i++) {
            log.info("  {}: {}", i + 1, history.get(i).getDescription());
        }
    }
}
```

### ä¼ä¸šçº§åº”ç”¨ - ä»»åŠ¡è°ƒåº¦ç³»ç»Ÿ

```java
// å¼‚æ­¥å‘½ä»¤æ¥å£
public interface AsyncCommand extends Command {
    CompletableFuture<Void> executeAsync();
    boolean isRetryable();
    int getMaxRetries();
}

// æ•°æ®åº“æ“ä½œå‘½ä»¤
@AllArgsConstructor
@Slf4j
public class DatabaseOperationCommand implements AsyncCommand {
    private final String sql;
    private final Object[] parameters;
    private final DataSource dataSource;
    private String rollbackSql;
    
    @Override
    public void execute() {
        executeSync();
    }
    
    @Override
    public CompletableFuture<Void> executeAsync() {
        return CompletableFuture.runAsync(this::executeSync);
    }
    
    private void executeSync() {
        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            
            for (int i = 0; i < parameters.length; i++) {
                stmt.setObject(i + 1, parameters[i]);
            }
            
            int affected = stmt.executeUpdate();
            log.info("æ•°æ®åº“æ“ä½œæˆåŠŸï¼Œå½±å“ {} è¡Œ", affected);
            
        } catch (SQLException e) {
            log.error("æ•°æ®åº“æ“ä½œå¤±è´¥: {}", sql, e);
            throw new RuntimeException("æ•°æ®åº“æ“ä½œå¤±è´¥", e);
        }
    }
    
    @Override
    public void undo() {
        if (rollbackSql != null) {
            try (Connection conn = dataSource.getConnection();
                 PreparedStatement stmt = conn.prepareStatement(rollbackSql)) {
                
                stmt.executeUpdate();
                log.info("å›æ»šæ“ä½œæˆåŠŸ");
                
            } catch (SQLException e) {
                log.error("å›æ»šæ“ä½œå¤±è´¥: {}", rollbackSql, e);
                throw new RuntimeException("å›æ»šæ“ä½œå¤±è´¥", e);
            }
        }
    }
    
    @Override
    public String getDescription() {
        return "æ•°æ®åº“æ“ä½œ: " + sql;
    }
    
    @Override
    public boolean isRetryable() {
        return true;
    }
    
    @Override
    public int getMaxRetries() {
        return 3;
    }
}

// å¼‚æ­¥å‘½ä»¤æ‰§è¡Œå™¨
@Component
@Slf4j
public class AsyncCommandExecutor {
    private final ExecutorService executorService;
    private final Map<String, CompletableFuture<Void>> runningTasks;
    
    public AsyncCommandExecutor() {
        this.executorService = Executors.newFixedThreadPool(10);
        this.runningTasks = new ConcurrentHashMap<>();
    }
    
    public CompletableFuture<Void> executeAsync(String taskId, AsyncCommand command) {
        log.info("å¼€å§‹å¼‚æ­¥æ‰§è¡Œå‘½ä»¤: {} - {}", taskId, command.getDescription());
        
        CompletableFuture<Void> future = command.executeAsync()
                .handle((result, throwable) -> {
                    if (throwable != null) {
                        return handleCommandFailure(command, throwable);
                    }
                    return result;
                })
                .whenComplete((result, throwable) -> {
                    runningTasks.remove(taskId);
                    if (throwable == null) {
                        log.info("å‘½ä»¤æ‰§è¡ŒæˆåŠŸ: {}", taskId);
                    } else {
                        log.error("å‘½ä»¤æ‰§è¡Œå¤±è´¥: {}", taskId, throwable);
                    }
                });
        
        runningTasks.put(taskId, future);
        return future;
    }
    
    private Void handleCommandFailure(AsyncCommand command, Throwable throwable) {
        if (command.isRetryable()) {
            return retryCommand(command, throwable);
        } else {
            log.error("å‘½ä»¤æ‰§è¡Œå¤±è´¥ä¸”ä¸å¯é‡è¯•: {}", command.getDescription(), throwable);
            throw new RuntimeException(throwable);
        }
    }
    
    private Void retryCommand(AsyncCommand command, Throwable lastError) {
        for (int retry = 1; retry <= command.getMaxRetries(); retry++) {
            try {
                log.info("é‡è¯•å‘½ä»¤ (ç¬¬ {} æ¬¡): {}", retry, command.getDescription());
                Thread.sleep(1000 * retry); // æŒ‡æ•°é€€é¿
                command.execute();
                return null;
            } catch (Exception e) {
                log.warn("å‘½ä»¤é‡è¯•å¤±è´¥ (ç¬¬ {} æ¬¡): {}", retry, command.getDescription(), e);
                lastError = e;
            }
        }
        
        log.error("å‘½ä»¤é‡è¯•æ¬¡æ•°ç”¨å°½: {}", command.getDescription(), lastError);
        throw new RuntimeException("å‘½ä»¤æ‰§è¡Œå¤±è´¥", lastError);
    }
    
    public void cancelTask(String taskId) {
        CompletableFuture<Void> task = runningTasks.get(taskId);
        if (task != null) {
            task.cancel(true);
            runningTasks.remove(taskId);
            log.info("ä»»åŠ¡å·²å–æ¶ˆ: {}", taskId);
        }
    }
    
    public List<String> getRunningTasks() {
        return new ArrayList<>(runningTasks.keySet());
    }
    
    @PreDestroy
    public void shutdown() {
        log.info("å…³é—­å¼‚æ­¥å‘½ä»¤æ‰§è¡Œå™¨");
        executorService.shutdown();
        try {
            if (!executorService.awaitTermination(60, TimeUnit.SECONDS)) {
                executorService.shutdownNow();
            }
        } catch (InterruptedException e) {
            executorService.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }
}
```

## ğŸ”„ å…¶ä»–é‡è¦è¡Œä¸ºå‹æ¨¡å¼

### æ¨¡æ¿æ–¹æ³•æ¨¡å¼

å®šä¹‰ä¸€ä¸ªæ“ä½œä¸­ç®—æ³•çš„éª¨æ¶ï¼Œè€Œå°†ä¸€äº›æ­¥éª¤å»¶è¿Ÿåˆ°å­ç±»ä¸­ã€‚

```java
// æŠ½è±¡æ¨¡æ¿ç±»
@Slf4j
public abstract class DataProcessor {
    
    // æ¨¡æ¿æ–¹æ³• - å®šä¹‰ç®—æ³•éª¨æ¶
    public final void processData(String data) {
        log.info("å¼€å§‹æ•°æ®å¤„ç†æµç¨‹");
        
        String validatedData = validateData(data);
        String transformedData = transformData(validatedData);
        String processedData = processBusinessLogic(transformedData);
        saveData(processedData);
        
        log.info("æ•°æ®å¤„ç†æµç¨‹å®Œæˆ");
    }
    
    // å…·ä½“æ–¹æ³• - é€šç”¨çš„æ•°æ®éªŒè¯
    private String validateData(String data) {
        log.info("éªŒè¯æ•°æ®: {}", data);
        if (data == null || data.trim().isEmpty()) {
            throw new IllegalArgumentException("æ•°æ®ä¸èƒ½ä¸ºç©º");
        }
        return data.trim();
    }
    
    // æŠ½è±¡æ–¹æ³• - ç”±å­ç±»å®ç°
    protected abstract String transformData(String data);
    protected abstract String processBusinessLogic(String data);
    
    // é’©å­æ–¹æ³• - å­ç±»å¯ä»¥é€‰æ‹©æ€§é‡å†™
    protected void saveData(String data) {
        log.info("ä¿å­˜æ•°æ®åˆ°é»˜è®¤å­˜å‚¨: {}", data);
    }
}

// å…·ä½“å®ç° - JSONæ•°æ®å¤„ç†å™¨
@Slf4j
public class JsonDataProcessor extends DataProcessor {
    
    @Override
    protected String transformData(String data) {
        log.info("JSONæ•°æ®è½¬æ¢: {}", data);
        // JSONç‰¹å®šçš„è½¬æ¢é€»è¾‘
        return "{\"processed\": \"" + data + "\"}";
    }
    
    @Override
    protected String processBusinessLogic(String data) {
        log.info("JSONä¸šåŠ¡é€»è¾‘å¤„ç†: {}", data);
        // JSONç‰¹å®šçš„ä¸šåŠ¡é€»è¾‘
        return data.replace("processed", "completed");
    }
    
    @Override
    protected void saveData(String data) {
        log.info("ä¿å­˜JSONæ•°æ®åˆ°MongoDB: {}", data);
    }
}

// å…·ä½“å®ç° - XMLæ•°æ®å¤„ç†å™¨
@Slf4j
public class XmlDataProcessor extends DataProcessor {
    
    @Override
    protected String transformData(String data) {
        log.info("XMLæ•°æ®è½¬æ¢: {}", data);
        return "<processed>" + data + "</processed>";
    }
    
    @Override
    protected String processBusinessLogic(String data) {
        log.info("XMLä¸šåŠ¡é€»è¾‘å¤„ç†: {}", data);
        return data.replace("processed", "completed");
    }
    
    @Override
    protected void saveData(String data) {
        log.info("ä¿å­˜XMLæ•°æ®åˆ°å…³ç³»æ•°æ®åº“: {}", data);
    }
}
```

### è´£ä»»é“¾æ¨¡å¼

é¿å…è¯·æ±‚å‘é€è€…ä¸æ¥æ”¶è€…è€¦åˆåœ¨ä¸€èµ·ï¼Œè®©å¤šä¸ªå¯¹è±¡éƒ½æœ‰å¯èƒ½æ¥æ”¶è¯·æ±‚ï¼Œå°†è¿™äº›å¯¹è±¡è¿æ¥æˆä¸€æ¡é“¾ï¼Œå¹¶ä¸”æ²¿ç€è¿™æ¡é“¾ä¼ é€’è¯·æ±‚ï¼Œç›´åˆ°æœ‰å¯¹è±¡å¤„ç†å®ƒä¸ºæ­¢ã€‚

```java
// æŠ½è±¡å¤„ç†å™¨
public abstract class RequestHandler {
    protected RequestHandler nextHandler;
    
    public void setNext(RequestHandler handler) {
        this.nextHandler = handler;
    }
    
    public abstract void handleRequest(Request request);
    
    protected void passToNext(Request request) {
        if (nextHandler != null) {
            nextHandler.handleRequest(request);
        } else {
            throw new RuntimeException("æ²¡æœ‰å¤„ç†å™¨èƒ½å¤Ÿå¤„ç†è¯·æ±‚: " + request.getType());
        }
    }
}

// è¯·æ±‚ç±»
@Getter
@AllArgsConstructor
public class Request {
    private final String type;
    private final String content;
    private final Map<String, Object> attributes;
}

// å…·ä½“å¤„ç†å™¨ - è®¤è¯å¤„ç†å™¨
@Slf4j
public class AuthenticationHandler extends RequestHandler {
    
    @Override
    public void handleRequest(Request request) {
        if ("AUTH".equals(request.getType())) {
            log.info("è®¤è¯å¤„ç†å™¨å¤„ç†è¯·æ±‚: {}", request.getContent());
            // è®¤è¯é€»è¾‘
            if (authenticate(request)) {
                log.info("è®¤è¯æˆåŠŸ");
            } else {
                throw new RuntimeException("è®¤è¯å¤±è´¥");
            }
        } else {
            passToNext(request);
        }
    }
    
    private boolean authenticate(Request request) {
        // æ¨¡æ‹Ÿè®¤è¯é€»è¾‘
        return request.getAttributes().containsKey("token");
    }
}

// å…·ä½“å¤„ç†å™¨ - æˆæƒå¤„ç†å™¨
@Slf4j
public class AuthorizationHandler extends RequestHandler {
    
    @Override
    public void handleRequest(Request request) {
        if ("AUTHZ".equals(request.getType())) {
            log.info("æˆæƒå¤„ç†å™¨å¤„ç†è¯·æ±‚: {}", request.getContent());
            // æˆæƒé€»è¾‘
            if (authorize(request)) {
                log.info("æˆæƒæˆåŠŸ");
            } else {
                throw new RuntimeException("æˆæƒå¤±è´¥");
            }
        } else {
            passToNext(request);
        }
    }
    
    private boolean authorize(Request request) {
        // æ¨¡æ‹Ÿæˆæƒé€»è¾‘
        return request.getAttributes().containsKey("role");
    }
}

// è´£ä»»é“¾æ„å»ºå™¨
public class HandlerChainBuilder {
    private RequestHandler first;
    private RequestHandler current;
    
    public HandlerChainBuilder addHandler(RequestHandler handler) {
        if (first == null) {
            first = handler;
            current = handler;
        } else {
            current.setNext(handler);
            current = handler;
        }
        return this;
    }
    
    public RequestHandler build() {
        return first;
    }
}

// ä½¿ç”¨ç¤ºä¾‹
public class ChainOfResponsibilityDemo {
    public static void main(String[] args) {
        // æ„å»ºè´£ä»»é“¾
        RequestHandler chain = new HandlerChainBuilder()
                .addHandler(new AuthenticationHandler())
                .addHandler(new AuthorizationHandler())
                .build();
        
        // åˆ›å»ºè¯·æ±‚
        Map<String, Object> attributes = Map.of(
                "token", "abc123",
                "role", "user"
        );
        
        Request authRequest = new Request("AUTH", "ç”¨æˆ·ç™»å½•", attributes);
        Request authzRequest = new Request("AUTHZ", "è®¿é—®èµ„æº", attributes);
        
        // å¤„ç†è¯·æ±‚
        chain.handleRequest(authRequest);
        chain.handleRequest(authzRequest);
    }
}
```

## ğŸš€ ç°ä»£Javaç‰¹æ€§åœ¨è¡Œä¸ºå‹æ¨¡å¼ä¸­çš„åº”ç”¨

### ä½¿ç”¨Stream APIå¢å¼ºè§‚å¯Ÿè€…æ¨¡å¼

```java
@Slf4j
public class StreamObservable<T> {
    private final List<Consumer<T>> observers = new CopyOnWriteArrayList<>();
    
    public void subscribe(Consumer<T> observer) {
        observers.add(observer);
    }
    
    public void publish(T event) {
        observers.parallelStream()
                .forEach(observer -> {
                    try {
                        observer.accept(event);
                    } catch (Exception e) {
                        log.error("è§‚å¯Ÿè€…å¤„ç†äº‹ä»¶å¤±è´¥", e);
                    }
                });
    }
    
    // æ”¯æŒæ¡ä»¶è¿‡æ»¤çš„å‘å¸ƒ
    public void publishIf(T event, Predicate<T> condition) {
        if (condition.test(event)) {
            publish(event);
        }
    }
    
    // æ”¯æŒäº‹ä»¶è½¬æ¢
    public <R> void publishMapped(T event, Function<T, R> mapper, 
                                  Consumer<R> observer) {
        try {
            R mappedEvent = mapper.apply(event);
            observer.accept(mappedEvent);
        } catch (Exception e) {
            log.error("äº‹ä»¶è½¬æ¢å¤±è´¥", e);
        }
    }
}
```

### ä½¿ç”¨Optionalå¢å¼ºè´£ä»»é“¾æ¨¡å¼

```java
// å‡½æ•°å¼è´£ä»»é“¾
@FunctionalInterface
public interface HandlerFunction<T> {
    Optional<T> handle(T request);
}

public class FunctionalChain<T> {
    private final List<HandlerFunction<T>> handlers = new ArrayList<>();
    
    public FunctionalChain<T> addHandler(HandlerFunction<T> handler) {
        handlers.add(handler);
        return this;
    }
    
    public Optional<T> process(T request) {
        return handlers.stream()
                .map(handler -> handler.handle(request))
                .filter(Optional::isPresent)
                .findFirst()
                .orElse(Optional.empty());
    }
}

// ä½¿ç”¨ç¤ºä¾‹
HandlerFunction<String> lengthHandler = request -> 
    request.length() > 10 ? Optional.of("é•¿æ–‡æœ¬å¤„ç†: " + request) : Optional.empty();

HandlerFunction<String> numberHandler = request -> 
    request.matches("\\d+") ? Optional.of("æ•°å­—å¤„ç†: " + request) : Optional.empty();

HandlerFunction<String> defaultHandler = request -> 
    Optional.of("é»˜è®¤å¤„ç†: " + request);

FunctionalChain<String> chain = new FunctionalChain<String>()
        .addHandler(lengthHandler)
        .addHandler(numberHandler)
        .addHandler(defaultHandler);

Optional<String> result = chain.process("12345");
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–ä¸æœ€ä½³å®è·µ

### è§‚å¯Ÿè€…æ¨¡å¼ä¼˜åŒ–

```java
// å¼‚æ­¥è§‚å¯Ÿè€…æ¨¡å¼
@Slf4j
public class AsyncObservable<T> {
    private final ExecutorService executorService;
    private final List<Consumer<T>> observers = new CopyOnWriteArrayList<>();
    
    public AsyncObservable(int threadPoolSize) {
        this.executorService = Executors.newFixedThreadPool(threadPoolSize);
    }
    
    public void subscribe(Consumer<T> observer) {
        observers.add(observer);
    }
    
    public CompletableFuture<Void> publishAsync(T event) {
        List<CompletableFuture<Void>> futures = observers.stream()
                .map(observer -> CompletableFuture.runAsync(() -> {
                    try {
                        observer.accept(event);
                    } catch (Exception e) {
                        log.error("å¼‚æ­¥è§‚å¯Ÿè€…å¤„ç†äº‹ä»¶å¤±è´¥", e);
                    }
                }, executorService))
                .collect(Collectors.toList());
        
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));
    }
    
    @PreDestroy
    public void shutdown() {
        executorService.shutdown();
    }
}
```

### ç­–ç•¥æ¨¡å¼ä¼˜åŒ– - ç­–ç•¥ç¼“å­˜

```java
@Component
public class CachedStrategyFactory {
    private final Map<String, PaymentStrategy> strategyCache = new ConcurrentHashMap<>();
    private final ApplicationContext applicationContext;
    
    public CachedStrategyFactory(ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
        initializeStrategies();
    }
    
    private void initializeStrategies() {
        Map<String, PaymentStrategy> strategies = 
            applicationContext.getBeansOfType(PaymentStrategy.class);
        
        strategies.values().forEach(strategy -> 
            strategyCache.put(strategy.getPaymentMethod(), strategy));
    }
    
    public PaymentStrategy getStrategy(String paymentMethod) {
        return strategyCache.get(paymentMethod);
    }
    
    public Set<String> getAvailableStrategies() {
        return strategyCache.values().stream()
                .filter(PaymentStrategy::isAvailable)
                .map(PaymentStrategy::getPaymentMethod)
                .collect(Collectors.toSet());
    }
}
```

## ğŸ¯ æ¨¡å¼é€‰æ‹©æŒ‡å—

### ä½¿ç”¨åœºæ™¯å†³ç­–è¡¨

| éœ€æ±‚æè¿° | æ¨èæ¨¡å¼ | å…³é”®ç‰¹å¾ |
|---------|---------|---------|
| éœ€è¦é€šçŸ¥å¤šä¸ªå¯¹è±¡çŠ¶æ€å˜åŒ– | è§‚å¯Ÿè€…æ¨¡å¼ | ä¸€å¯¹å¤šä¾èµ– |
| ç®—æ³•éœ€è¦åœ¨è¿è¡Œæ—¶åˆ‡æ¢ | ç­–ç•¥æ¨¡å¼ | ç®—æ³•æ—æ›¿æ¢ |
| éœ€è¦æ”¯æŒæ’¤é”€/é‡åšæ“ä½œ | å‘½ä»¤æ¨¡å¼ | æ“ä½œå°è£… |
| æœ‰å›ºå®šçš„å¤„ç†æµç¨‹éª¨æ¶ | æ¨¡æ¿æ–¹æ³•æ¨¡å¼ | ç®—æ³•éª¨æ¶ |
| è¯·æ±‚éœ€è¦å¤šä¸ªå¯¹è±¡å¤„ç† | è´£ä»»é“¾æ¨¡å¼ | é“¾å¼å¤„ç† |
| å¯¹è±¡è¡Œä¸ºéšçŠ¶æ€æ”¹å˜ | çŠ¶æ€æ¨¡å¼ | çŠ¶æ€è½¬æ¢ |
| éœ€è¦åœ¨ä¸ä¿®æ”¹ç±»çš„å‰æä¸‹å¢åŠ æ“ä½œ | è®¿é—®è€…æ¨¡å¼ | æ“ä½œå¤–ç½® |

### æ€§èƒ½è€ƒè™‘

1. **è§‚å¯Ÿè€…æ¨¡å¼** - è€ƒè™‘å¼‚æ­¥é€šçŸ¥ï¼Œé¿å…é˜»å¡
2. **ç­–ç•¥æ¨¡å¼** - ä½¿ç”¨ç¼“å­˜é¿å…é‡å¤åˆ›å»ºç­–ç•¥å¯¹è±¡
3. **å‘½ä»¤æ¨¡å¼** - é™åˆ¶å†å²è®°å½•å¤§å°ï¼Œé¿å…å†…å­˜æ³„æ¼
4. **è´£ä»»é“¾æ¨¡å¼** - ä¼˜åŒ–é“¾é•¿åº¦ï¼Œé¿å…è¿‡é•¿çš„å¤„ç†é“¾

## ğŸ“ˆ æ€»ç»“

è¡Œä¸ºå‹æ¨¡å¼ä¸ºæˆ‘ä»¬æä¾›äº†å¼ºå¤§çš„å·¥å…·æ¥ç®¡ç†å¯¹è±¡é—´çš„äº¤äº’ï¼š

1. **è§‚å¯Ÿè€…æ¨¡å¼** - å®ç°æ¾è€¦åˆçš„äº‹ä»¶é€šçŸ¥
2. **ç­–ç•¥æ¨¡å¼** - å°è£…ç®—æ³•æ—ï¼Œæ”¯æŒè¿è¡Œæ—¶åˆ‡æ¢
3. **å‘½ä»¤æ¨¡å¼** - å°è£…è¯·æ±‚ï¼Œæ”¯æŒæ’¤é”€å’Œé˜Ÿåˆ—æ“ä½œ
4. **æ¨¡æ¿æ–¹æ³•æ¨¡å¼** - å®šä¹‰ç®—æ³•éª¨æ¶ï¼Œå­ç±»å®ç°ç»†èŠ‚
5. **è´£ä»»é“¾æ¨¡å¼** - é“¾å¼å¤„ç†è¯·æ±‚ï¼Œé¿å…å‘é€è€…ä¸æ¥æ”¶è€…è€¦åˆ

### æ ¸å¿ƒåŸåˆ™

- **å¼€é—­åŸåˆ™** - å¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å…³é—­
- **å•ä¸€èŒè´£** - æ¯ä¸ªç±»åªè´Ÿè´£ä¸€ä¸ªèŒè´£
- **ä¾èµ–å€’ç½®** - ä¾èµ–æŠ½è±¡è€Œä¸æ˜¯å…·ä½“å®ç°
- **æœ€å°‘çŸ¥è¯†åŸåˆ™** - å‡å°‘å¯¹è±¡é—´çš„ç›´æ¥ä¾èµ–

é€šè¿‡åˆç†åº”ç”¨è¡Œä¸ºå‹æ¨¡å¼ï¼Œæˆ‘ä»¬èƒ½å¤Ÿæ„å»ºå‡ºæ›´åŠ çµæ´»ã€å¯ç»´æŠ¤å’Œå¯æ‰©å±•çš„Javaåº”ç”¨ç¨‹åºã€‚

## ğŸ”— ç›¸å…³èµ„æº

- [é¡¹ç›®æºä»£ç ](https://github.com/Rise1024/Java-Labs/tree/main/java-design-patterns#readme)
- [Javaè®¾è®¡æ¨¡å¼ç³»åˆ—æ–‡ç« ](../README.md)
- [åˆ›å»ºå‹æ¨¡å¼è¯¦è§£](./01-Javaè®¾è®¡æ¨¡å¼å®æˆ˜ï¼šåˆ›å»ºå‹æ¨¡å¼æ·±åº¦è§£æ.md)
- [ç»“æ„å‹æ¨¡å¼è¯¦è§£](./02-Javaè®¾è®¡æ¨¡å¼å®æˆ˜ï¼šç»“æ„å‹æ¨¡å¼æ·±åº¦è§£æ.md)
- [ç‰›é€¼çš„åšå®¢ç½‘ç«™](https://dongsheng.online)
