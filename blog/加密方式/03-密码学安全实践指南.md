---
title: å¯†ç å­¦å®‰å…¨å®è·µï¼šå“ˆå¸Œç®—æ³•ã€æ•°å­—ç­¾åä¸å®‰å…¨å¼€å‘æŒ‡å—
description: å¯†ç å­¦å®‰å…¨å®è·µï¼šå“ˆå¸Œç®—æ³•ã€æ•°å­—ç­¾åä¸å®‰å…¨å¼€å‘æŒ‡å—
tags: [Java, å“ˆå¸Œç®—æ³•, æ•°å­—ç­¾å]
category: åŠ å¯†æ–¹å¼
date: 2025-09-26
---
# å¯†ç å­¦å®‰å…¨å®è·µï¼šå“ˆå¸Œç®—æ³•ã€æ•°å­—ç­¾åä¸å®‰å…¨å¼€å‘æŒ‡å—

## ğŸ¯ å¼•è¨€

æ·±å…¥æ¢è®¨ç°ä»£å¯†ç å­¦çš„å®‰å…¨å®è·µï¼ŒåŒ…æ‹¬å“ˆå¸Œç®—æ³•ã€æ•°å­—ç­¾åã€å¯†ç å­˜å‚¨ç­‰å…³é”®æŠ€æœ¯é¢†åŸŸã€‚

## ğŸ§® å“ˆå¸Œç®—æ³•æ·±åº¦è§£æ

### å¯†ç å­¦å“ˆå¸Œå‡½æ•°çš„ç‰¹æ€§

ä¸€ä¸ªå®‰å…¨çš„å¯†ç å­¦å“ˆå¸Œå‡½æ•°å¿…é¡»æ»¡è¶³ä»¥ä¸‹ç‰¹æ€§ï¼š

1. **ç¡®å®šæ€§**: ç›¸åŒè¾“å…¥æ€»æ˜¯äº§ç”Ÿç›¸åŒè¾“å‡º
2. **å¿«é€Ÿè®¡ç®—**: è®¡ç®—å“ˆå¸Œå€¼çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(n)
3. **é›ªå´©æ•ˆåº”**: è¾“å…¥çš„å¾®å°å˜åŒ–å¯¼è‡´è¾“å‡ºçš„å·¨å¤§å˜åŒ–
4. **å•å‘æ€§**: ä»å“ˆå¸Œå€¼æ¨å¯¼åŸå§‹æ•°æ®åœ¨è®¡ç®—ä¸Šä¸å¯è¡Œ
5. **æŠ—ç¢°æ’æ€§**: æ‰¾åˆ°ä¸¤ä¸ªäº§ç”Ÿç›¸åŒå“ˆå¸Œå€¼çš„ä¸åŒè¾“å…¥åœ¨è®¡ç®—ä¸Šä¸å¯è¡Œ

### ç°ä»£å“ˆå¸Œç®—æ³•å®ç°

#### SHA-2ç³»åˆ—ç®—æ³•

æˆ‘ä»¬çš„å®ç°æ”¯æŒå®Œæ•´çš„SHA-2ç³»åˆ—ï¼š

```java
public static DigestResult sha256(String input) {
    return digest(input, "SHA-256");
}

public static DigestResult sha512(String input) {
    return digest(input, "SHA-512");
}

private static DigestResult digest(String input, String algorithm) {
    try {
        MessageDigest digest = MessageDigest.getInstance(algorithm);
        byte[] inputBytes = CryptoUtils.stringToBytes(input);
        byte[] hashBytes = digest.digest(inputBytes);
        
        log.info("{}æ‘˜è¦å®Œæˆ - è¾“å…¥é•¿åº¦: {}, æ‘˜è¦é•¿åº¦: {} bytes", 
                algorithm, input.length(), hashBytes.length);
        
        return new DigestResult(
            CryptoUtils.bytesToHex(hashBytes),
            CryptoUtils.bytesToBase64(hashBytes),
            algorithm,
            hashBytes.length * 8
        );
    } catch (Exception e) {
        throw new CryptoException(algorithm + "æ‘˜è¦è®¡ç®—å¤±è´¥", e);
    }
}
```

#### SHA-3ç®—æ³•ï¼ˆKeccakï¼‰

SHA-3ä»£è¡¨äº†å“ˆå¸Œç®—æ³•çš„æœ€æ–°å‘å±•ï¼š

```java
public static DigestResult sha3_256(String input) {
    return digest(input, "SHA3-256");
}

public static DigestResult sha3_512(String input) {
    return digest(input, "SHA3-512");
}
```

**SHA-2 vs SHA-3å¯¹æ¯”**:

| ç‰¹æ€§ | SHA-2 | SHA-3 |
|------|-------|-------|
| è®¾è®¡åŸç† | Merkle-DamgÃ¥rd | æµ·ç»µæ„é€  |
| å®‰å…¨æ€§ | é«˜ | æ›´é«˜ |
| æ€§èƒ½ | ä¼˜ç§€ | è‰¯å¥½ |
| ç¡¬ä»¶å®ç° | æˆç†Ÿ | å‘å±•ä¸­ |
| åº”ç”¨åœºæ™¯ | å¹¿æ³›ä½¿ç”¨ | é«˜å®‰å…¨è¦æ±‚ |

### å·²åºŸå¼ƒç®—æ³•çš„å®‰å…¨åˆ†æ

#### MD5å’ŒSHA-1çš„å®‰å…¨é—®é¢˜

```java
public static DigestResult md5(String input) {
    log.warn("MD5ç®—æ³•å­˜åœ¨å®‰å…¨é£é™©ï¼Œä¸æ¨èç”¨äºå®‰å…¨åœºæ™¯");
    return digest(input, "MD5");
}

public static DigestResult sha1(String input) {
    log.warn("SHA-1ç®—æ³•å­˜åœ¨å®‰å…¨é£é™©ï¼Œä¸æ¨èç”¨äºå®‰å…¨åœºæ™¯");
    return digest(input, "SHA-1");
}
```

**å®‰å…¨é—®é¢˜åˆ†æ**:
- **MD5**: 1996å¹´å‘ç°ç¢°æ’æ”»å‡»ï¼Œ2004å¹´å®ç”¨åŒ–ï¼Œ2017å¹´è¢«SHAtteredæ”»å‡»å®Œå…¨ç ´è§£
- **SHA-1**: 2005å¹´ç†è®ºæ”»å‡»ï¼Œ2017å¹´Googleå®ç°å®é™…ç¢°æ’
- **å½±å“**: æ•°å­—ç­¾åä¼ªé€ ã€SSLè¯ä¹¦æ¬ºéª—ã€è½¯ä»¶å®Œæ•´æ€§éªŒè¯ç»•è¿‡

**è¿ç§»å»ºè®®**:
```java
// é”™è¯¯ï¼šä½¿ç”¨å·²åºŸå¼ƒç®—æ³•
String hash = DigestUtils.md5Hex(data);

// æ­£ç¡®ï¼šä½¿ç”¨ç°ä»£å®‰å…¨ç®—æ³•
DigestResult result = DigestCrypto.sha256(data);
String hash = result.hexHash();
```

## ğŸ” æ¶ˆæ¯è®¤è¯ç ï¼ˆHMACï¼‰

### HMACåŸç†ä¸å®ç°

HMACï¼ˆHash-based Message Authentication Codeï¼‰æä¾›äº†æ•°æ®å®Œæ•´æ€§å’Œèº«ä»½è®¤è¯ï¼š

```java
public static DigestResult hmacSHA256(String input, String keyBase64) {
    return hmac(input, keyBase64, "HmacSHA256");
}

private static DigestResult hmac(String input, String keyBase64, String algorithm) {
    try {
        // è§£æå¯†é’¥
        byte[] keyBytes = CryptoUtils.base64ToBytes(keyBase64);
        SecretKeySpec secretKey = new SecretKeySpec(keyBytes, algorithm);
        
        // åˆå§‹åŒ–MAC
        Mac mac = Mac.getInstance(algorithm);
        mac.init(secretKey);
        
        // è®¡ç®—HMAC
        byte[] inputBytes = CryptoUtils.stringToBytes(input);
        byte[] hmacBytes = mac.doFinal(inputBytes);
        
        return new DigestResult(
            CryptoUtils.bytesToHex(hmacBytes),
            CryptoUtils.bytesToBase64(hmacBytes),
            algorithm,
            hmacBytes.length * 8
        );
    } catch (Exception e) {
        throw new CryptoException(algorithm + "è®¡ç®—å¤±è´¥", e);
    }
}
```

#### HMACå¯†é’¥ç®¡ç†

```java
public static String generateHMACKey(int keyLength) {
    if (keyLength <= 0) {
        throw new IllegalArgumentException("å¯†é’¥é•¿åº¦å¿…é¡»å¤§äº0");
    }
    
    // å¯†é’¥é•¿åº¦å»ºè®®ï¼š
    // HMAC-SHA256: 32å­—èŠ‚
    // HMAC-SHA512: 64å­—èŠ‚
    byte[] keyBytes = CryptoUtils.generateSecureRandomBytes(keyLength);
    return CryptoUtils.bytesToBase64(keyBytes);
}
```

#### HMACéªŒè¯å®ç°

```java
public static boolean verifyHMAC(String input, String keyBase64, DigestResult expectedHmac, String algorithm) {
    try {
        DigestResult actualHmac = hmac(input, keyBase64, algorithm);
        
        // ä½¿ç”¨æ’æ—¶é—´æ¯”è¾ƒé˜²æ­¢æ—¶åºæ”»å‡»
        boolean matches = CryptoUtils.secureEquals(
            CryptoUtils.hexToBytes(actualHmac.hexHash()),
            CryptoUtils.hexToBytes(expectedHmac.hexHash())
        );
        
        log.info("HMACéªŒè¯ç»“æœ: {}", matches ? "åŒ¹é…" : "ä¸åŒ¹é…");
        return matches;
        
    } catch (Exception e) {
        log.error("HMACéªŒè¯å¤±è´¥", e);
        return false;
    }
}
```

### æ—¶åºæ”»å‡»é˜²æŠ¤

```java
public static boolean secureEquals(byte[] a, byte[] b) {
    if (a == null || b == null) {
        return a == b;
    }
    
    if (a.length != b.length) {
        return false;
    }
    
    // æ’æ—¶é—´æ¯”è¾ƒï¼Œé˜²æ­¢æ—¶åºæ”»å‡»
    int result = 0;
    for (int i = 0; i < a.length; i++) {
        result |= a[i] ^ b[i];
    }
    
    return result == 0;
}
```

**ä¸ºä»€ä¹ˆéœ€è¦æ’æ—¶é—´æ¯”è¾ƒï¼Ÿ**
- ä¼ ç»Ÿçš„å­—ç¬¦ä¸²æ¯”è¾ƒåœ¨é‡åˆ°ç¬¬ä¸€ä¸ªä¸åŒå­—ç¬¦æ—¶å°±è¿”å›ï¼Œæ—¶é—´ä¸ç›¸åŒå‰ç¼€é•¿åº¦ç›¸å…³
- æ”»å‡»è€…å¯ä»¥é€šè¿‡æµ‹é‡æ¯”è¾ƒæ—¶é—´æ¥é€ä½çŒœæµ‹æ­£ç¡®çš„HMACå€¼
- æ’æ—¶é—´æ¯”è¾ƒç¡®ä¿æ— è®ºæ•°æ®æ˜¯å¦åŒ¹é…ï¼Œæ‰§è¡Œæ—¶é—´éƒ½ç›¸åŒ

## ğŸ”‘ å¯†ç å“ˆå¸Œç®—æ³•

### PBKDF2å®ç°ä¸å®‰å…¨åˆ†æ

PBKDF2ï¼ˆPassword-Based Key Derivation Function 2ï¼‰æ˜¯å½“å‰æ¨èçš„å¯†ç å“ˆå¸Œç®—æ³•ï¼š

```java
public static PasswordHashResult pbkdf2Hash(String password, String saltBase64, int iterations, int hashLength) {
    if (iterations < 10_000) {
        log.warn("PBKDF2è¿­ä»£æ¬¡æ•°è¿‡ä½ï¼Œå»ºè®®è‡³å°‘100,000æ¬¡");
    }
    
    try {
        byte[] salt = CryptoUtils.base64ToBytes(saltBase64);
        
        // åˆ›å»ºPBKDF2è§„èŒƒ
        PBEKeySpec spec = new PBEKeySpec(
            password.toCharArray(), 
            salt, 
            iterations, 
            hashLength * 8
        );
        
        SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
        byte[] hash = factory.generateSecret(spec).getEncoded();
        
        // æ¸…é™¤æ•æ„Ÿæ•°æ®
        spec.clearPassword();
        CryptoUtils.clearSensitiveData(password.toCharArray());
        
        return new PasswordHashResult(
            CryptoUtils.bytesToHex(hash),
            CryptoUtils.bytesToBase64(hash),
            saltBase64,
            "PBKDF2WithHmacSHA256",
            iterations,
            hash.length * 8
        );
    } catch (Exception e) {
        throw new CryptoException("PBKDF2å¯†ç å“ˆå¸Œå¤±è´¥", e);
    }
}
```

#### PBKDF2å‚æ•°é€‰æ‹©

**è¿­ä»£æ¬¡æ•°é€‰æ‹©**:
```java
// 2024å¹´OWASPæ¨èå‚æ•°
private static final int DEFAULT_PBKDF2_ITERATIONS = 600_000; // PBKDF2-SHA256
private static final int PBKDF2_SHA1_ITERATIONS = 1_300_000;  // PBKDF2-SHA1ï¼ˆä¸æ¨èï¼‰
```

**ç›å€¼ç®¡ç†**:
```java
public static String generateSalt(int length) {
    // ç›å€¼é•¿åº¦å»ºè®®ï¼šè‡³å°‘16å­—èŠ‚ï¼Œæ¨è32å­—èŠ‚
    if (length < 16) {
        log.warn("ç›å€¼é•¿åº¦è¿‡çŸ­ï¼Œå»ºè®®è‡³å°‘16å­—èŠ‚");
    }
    
    byte[] salt = CryptoUtils.generateSecureRandomBytes(length);
    return CryptoUtils.bytesToBase64(salt);
}
```

### BCryptå®ç°ä¸ç‰¹ç‚¹

BCryptæ˜¯å¦ä¸€ç§ä¼˜ç§€çš„å¯†ç å“ˆå¸Œç®—æ³•ï¼Œå…·æœ‰è‡ªé€‚åº”ç‰¹æ€§ï¼š

```java
public static BCryptResult bcryptHash(String password, int rounds) {
    if (rounds < MIN_BCRYPT_ROUNDS || rounds > MAX_BCRYPT_ROUNDS) {
        throw new IllegalArgumentException(
            String.format("BCryptè½®æ•°å¿…é¡»åœ¨%d-%dä¹‹é—´", MIN_BCRYPT_ROUNDS, MAX_BCRYPT_ROUNDS));
    }
    
    try {
        String salt = BCrypt.gensalt(rounds);
        String hash = BCrypt.hashpw(password, salt);
        
        return new BCryptResult(hash, salt, rounds);
    } catch (Exception e) {
        throw new CryptoException("BCryptå¯†ç å“ˆå¸Œå¤±è´¥", e);
    }
}
```

#### BCrypt vs PBKDF2å¯¹æ¯”

| ç‰¹æ€§ | BCrypt | PBKDF2 |
|------|--------|--------|
| ç®—æ³•åŸºç¡€ | Blowfish | HMAC |
| å†…å­˜éœ€æ±‚ | è¾ƒé«˜ï¼ˆ4KBï¼‰ | è¾ƒä½ |
| æŠ—ASICæ”»å‡» | æ›´å¥½ | ä¸€èˆ¬ |
| æ ‡å‡†åŒ–ç¨‹åº¦ | äº‹å®æ ‡å‡† | RFCæ ‡å‡† |
| å®ç°å¤æ‚åº¦ | ä¸­ç­‰ | ç®€å• |
| æ¨èåœºæ™¯ | é«˜å®‰å…¨è¦æ±‚ | ä¸€èˆ¬åº”ç”¨ |

### ç°ä»£å¯†ç å“ˆå¸Œï¼šArgon2

è™½ç„¶æˆ‘ä»¬çš„é¡¹ç›®æš‚æœªå®ç°Argon2ï¼Œä½†å€¼å¾—äº†è§£å…¶ä¼˜åŠ¿ï¼š

```java
// Argon2ç¤ºä¾‹ï¼ˆéœ€è¦é¢å¤–ä¾èµ–ï¼‰
public class Argon2Example {
    public static String hashPassword(String password) {
        Argon2 argon2 = Argon2Factory.create(Argon2Types.ARGON2id);
        
        return argon2.hash(
            10,          // è¿­ä»£æ¬¡æ•°
            65536,       // å†…å­˜ä½¿ç”¨ï¼ˆKBï¼‰
            1,           // å¹¶è¡Œåº¦
            password.toCharArray()
        );
    }
}
```

**Argon2ä¼˜åŠ¿**:
- åŒæ—¶æŠµæŠ—æ—¶é—´å’Œå†…å­˜æ”»å‡»
- ä¸‰ç§å˜ä½“ï¼šArgon2dã€Argon2iã€Argon2id
- 2015å¹´å¯†ç å“ˆå¸Œç«èµ›è·èƒœè€…

## âœï¸ æ•°å­—ç­¾åæŠ€æœ¯

### RSAæ•°å­—ç­¾åå®ç°

è™½ç„¶æˆ‘ä»¬çš„RSAå®ç°ä¸»è¦ç”¨äºæ¼”ç¤ºåŠ å¯†ï¼Œä½†å…¶ç§é’¥åŠ å¯†/å…¬é’¥è§£å¯†æ¨¡å¼å±•ç¤ºäº†æ•°å­—ç­¾åçš„åŸºæœ¬åŸç†ï¼š

```java
// æ•°å­—ç­¾ååŸç†æ¼”ç¤º
public static String signMessage(String message, String privateKey) {
    // 1. è®¡ç®—æ¶ˆæ¯å“ˆå¸Œ
    DigestResult messageHash = DigestCrypto.sha256(message);
    
    // 2. ç”¨ç§é’¥"åŠ å¯†"å“ˆå¸Œå€¼
    RSAResult signature = RSACrypto.encryptWithPrivateKey(messageHash.hexHash(), privateKey);
    
    return signature.base64CipherText();
}

public static boolean verifySignature(String message, String signature, String publicKey) {
    try {
        // 1. è®¡ç®—æ¶ˆæ¯å“ˆå¸Œ
        DigestResult expectedHash = DigestCrypto.sha256(message);
        
        // 2. ç”¨å…¬é’¥"è§£å¯†"ç­¾å
        RSAResult signatureResult = new RSAResult("", signature, "SIGNATURE");
        String decryptedHash = RSACrypto.decryptWithPublicKey(signatureResult, publicKey);
        
        // 3. æ¯”è¾ƒå“ˆå¸Œå€¼
        return expectedHash.hexHash().equals(decryptedHash);
    } catch (Exception e) {
        return false;
    }
}
```

### æ ‡å‡†æ•°å­—ç­¾åå®ç°

å®é™…ç”Ÿäº§ç¯å¢ƒåº”ä½¿ç”¨æ ‡å‡†çš„æ•°å­—ç­¾åAPIï¼š

```java
public class StandardDigitalSignature {
    
    public static byte[] signSHA256withRSA(byte[] data, PrivateKey privateKey) throws Exception {
        Signature signature = Signature.getInstance("SHA256withRSA");
        signature.initSign(privateKey);
        signature.update(data);
        return signature.sign();
    }
    
    public static boolean verifySHA256withRSA(byte[] data, byte[] signatureBytes, PublicKey publicKey) throws Exception {
        Signature signature = Signature.getInstance("SHA256withRSA");
        signature.initVerify(publicKey);
        signature.update(data);
        return signature.verify(signatureBytes);
    }
}
```

### æ¤­åœ†æ›²çº¿æ•°å­—ç­¾åï¼ˆECDSAï¼‰

ECDSAæä¾›äº†æ¯”RSAæ›´é«˜çš„æ€§èƒ½å’Œå®‰å…¨æ€§ï¼š

```java
public class ECDSAExample {
    
    public static KeyPair generateECKeyPair() throws Exception {
        KeyPairGenerator keyGen = KeyPairGenerator.getInstance("EC");
        ECGenParameterSpec spec = new ECGenParameterSpec("secp256r1"); // P-256æ›²çº¿
        keyGen.initialize(spec);
        return keyGen.generateKeyPair();
    }
    
    public static byte[] signECDSA(byte[] data, PrivateKey privateKey) throws Exception {
        Signature signature = Signature.getInstance("SHA256withECDSA");
        signature.initSign(privateKey);
        signature.update(data);
        return signature.sign();
    }
}
```

**ECDSA vs RSAå¯¹æ¯”**:

| ç‰¹æ€§ | ECDSA P-256 | RSA-2048 |
|------|-------------|----------|
| å®‰å…¨çº§åˆ« | 128ä½ | 112ä½ |
| å…¬é’¥é•¿åº¦ | 64å­—èŠ‚ | 256å­—èŠ‚ |
| ç§é’¥é•¿åº¦ | 32å­—èŠ‚ | 256å­—èŠ‚ |
| ç­¾åé•¿åº¦ | 64å­—èŠ‚ | 256å­—èŠ‚ |
| æ€§èƒ½ | æ›´å¿« | è¾ƒæ…¢ |

## ğŸ›¡ï¸ å¯†ç å­¦å®‰å…¨æœ€ä½³å®è·µ

### 1. å¯†é’¥ç®¡ç†

#### å¯†é’¥ç”Ÿæˆ
```java
public class SecureKeyGeneration {
    
    // ä½¿ç”¨å¯†ç å­¦å®‰å…¨çš„éšæœºæ•°ç”Ÿæˆå™¨
    public static byte[] generateKey(int length) throws Exception {
        SecureRandom secureRandom = SecureRandom.getInstanceStrong();
        byte[] key = new byte[length];
        secureRandom.nextBytes(key);
        return key;
    }
    
    // ä»å¯†ç æ´¾ç”Ÿå¯†é’¥
    public static byte[] deriveKeyFromPassword(String password, byte[] salt, int iterations) throws Exception {
        PBEKeySpec spec = new PBEKeySpec(password.toCharArray(), salt, iterations, 256);
        SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
        return factory.generateSecret(spec).getEncoded();
    }
}
```

#### å¯†é’¥å­˜å‚¨
```java
public class KeyStorage {
    
    // é”™è¯¯ï¼šç¡¬ç¼–ç å¯†é’¥
    private static final String API_KEY = "sk-1234567890abcdef"; // å±é™©ï¼
    
    // æ­£ç¡®ï¼šä»å®‰å…¨é…ç½®è¯»å–
    public static String getApiKey() {
        return System.getenv("API_KEY"); // ä»ç¯å¢ƒå˜é‡è¯»å–
    }
    
    // æ›´å¥½ï¼šä½¿ç”¨å¯†é’¥ç®¡ç†æœåŠ¡
    public static String getApiKeyFromVault() {
        // ä»HashiCorp Vaultã€AWS KMSç­‰è·å–
        return KeyVaultClient.getSecret("api-key");
    }
}
```

### 2. éšæœºæ•°ç”Ÿæˆ

#### å®‰å…¨çš„éšæœºæ•°ç”Ÿæˆ
```java
public class SecureRandomUtils {
    
    // çº¿ç¨‹å®‰å…¨çš„å¼ºéšæœºæ•°ç”Ÿæˆå™¨
    private static final SecureRandom SECURE_RANDOM;
    
    static {
        try {
            SECURE_RANDOM = SecureRandom.getInstanceStrong();
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("æ— æ³•è·å–å¼ºéšæœºæ•°ç”Ÿæˆå™¨", e);
        }
    }
    
    public static byte[] generateRandomBytes(int length) {
        byte[] bytes = new byte[length];
        SECURE_RANDOM.nextBytes(bytes);
        return bytes;
    }
    
    public static String generateRandomString(int length) {
        byte[] bytes = generateRandomBytes(length);
        return Base64.getUrlEncoder().withoutPadding().encodeToString(bytes);
    }
}
```

#### éšæœºæ•°è´¨é‡æ£€æµ‹
```java
public class RandomnessTest {
    
    public static void testRandomness(byte[] data) {
        // ç®€å•çš„éšæœºæ€§æµ‹è¯•
        Map<Byte, Integer> frequency = new HashMap<>();
        
        for (byte b : data) {
            frequency.merge(b, 1, Integer::sum);
        }
        
        // è®¡ç®—å¡æ–¹ç»Ÿè®¡é‡
        double expected = data.length / 256.0;
        double chiSquare = frequency.values().stream()
            .mapToDouble(count -> Math.pow(count - expected, 2) / expected)
            .sum();
        
        // è‡ªç”±åº¦255ï¼Œæ˜¾è‘—æ€§æ°´å¹³0.05çš„ä¸´ç•Œå€¼çº¦ä¸º293.25
        boolean isRandom = chiSquare < 293.25;
        
        log.info("éšæœºæ€§æµ‹è¯• - å¡æ–¹å€¼: {}, ç»“æœ: {}", chiSquare, isRandom ? "é€šè¿‡" : "ä¸é€šè¿‡");
    }
}
```

### 3. å†…å­˜å®‰å…¨

#### æ•æ„Ÿæ•°æ®æ¸…é™¤
```java
public class MemorySecurity {
    
    // æ¸…é™¤å­—èŠ‚æ•°ç»„
    public static void clearBytes(byte[] data) {
        if (data != null) {
            Arrays.fill(data, (byte) 0);
        }
    }
    
    // æ¸…é™¤å­—ç¬¦æ•°ç»„
    public static void clearChars(char[] data) {
        if (data != null) {
            Arrays.fill(data, '\0');
        }
    }
    
    // å®‰å…¨çš„å­—ç¬¦ä¸²å¤„ç†
    public static void processPassword(char[] password) {
        try {
            // å¤„ç†å¯†ç ...
            
        } finally {
            // ç¡®ä¿æ¸…é™¤å¯†ç 
            clearChars(password);
        }
    }
}
```

#### åƒåœ¾æ”¶é›†å™¨è€ƒè™‘
```java
public class GCSecurityConsiderations {
    
    // å°½é‡é¿å…Stringå­˜å‚¨æ•æ„Ÿæ•°æ®
    public void badExample(String password) {
        // Stringæ˜¯ä¸å¯å˜çš„ï¼Œå¯†ç ä¼šåœ¨å†…å­˜ä¸­ç•™å­˜ç›´åˆ°GC
        byte[] hash = hashPassword(password);
    }
    
    // ä½¿ç”¨char[]æ•°ç»„
    public void goodExample(char[] password) {
        try {
            byte[] hash = hashPassword(password);
        } finally {
            Arrays.fill(password, '\0'); // ç«‹å³æ¸…é™¤
        }
    }
}
```

## âš ï¸ å¸¸è§å®‰å…¨é™·é˜±

### 1. å¼±éšæœºæ•°ä½¿ç”¨

```java
// å±é™©ï¼šä½¿ç”¨java.util.Random
Random random = new Random();
byte[] key = new byte[16];
random.nextBytes(key); // å¯é¢„æµ‹ï¼

// å®‰å…¨ï¼šä½¿ç”¨SecureRandom
SecureRandom secureRandom = new SecureRandom();
byte[] key = new byte[16];
secureRandom.nextBytes(key);
```

### 2. ä¸å½“çš„å¼‚å¸¸å¤„ç†

```java
// å±é™©ï¼šæ³„éœ²ä¿¡æ¯çš„å¼‚å¸¸å¤„ç†
public boolean authenticateUser(String username, String password) {
    try {
        User user = findUser(username);
        if (user == null) {
            throw new AuthenticationException("ç”¨æˆ·ä¸å­˜åœ¨");
        }
        
        if (!verifyPassword(password, user.getPasswordHash())) {
            throw new AuthenticationException("å¯†ç é”™è¯¯");
        }
        
        return true;
    } catch (AuthenticationException e) {
        log.error("è®¤è¯å¤±è´¥: " + e.getMessage()); // æ³„éœ²äº†å¤±è´¥åŸå› 
        throw e;
    }
}

// å®‰å…¨ï¼šç»Ÿä¸€çš„é”™è¯¯æ¶ˆæ¯
public boolean authenticateUser(String username, String password) {
    try {
        User user = findUser(username);
        if (user == null) {
            return false;
        }
        
        return verifyPassword(password, user.getPasswordHash());
    } catch (Exception e) {
        log.error("è®¤è¯è¿‡ç¨‹å‘ç”Ÿé”™è¯¯"); // ä¸æ³„éœ²å…·ä½“ä¿¡æ¯
        return false;
    }
}
```

### 3. æ—¶åºæ”»å‡»æ¼æ´

```java
// å±é™©ï¼šå¯èƒ½çš„æ—¶åºæ”»å‡»
public boolean verifyToken(String providedToken, String expectedToken) {
    return providedToken.equals(expectedToken); // ä¸å®‰å…¨çš„æ¯”è¾ƒ
}

// å®‰å…¨ï¼šæ’æ—¶é—´æ¯”è¾ƒ
public boolean verifyToken(String providedToken, String expectedToken) {
    if (providedToken == null || expectedToken == null) {
        return false;
    }
    
    if (providedToken.length() != expectedToken.length()) {
        return false;
    }
    
    byte[] provided = providedToken.getBytes(StandardCharsets.UTF_8);
    byte[] expected = expectedToken.getBytes(StandardCharsets.UTF_8);
    
    return CryptoUtils.secureEquals(provided, expected);
}
```

## ğŸ” å®‰å…¨å®¡è®¡ä¸æµ‹è¯•

### 1. å•å…ƒæµ‹è¯•

```java
@Test
public void testPasswordHashing() {
    String password = "testPassword123!";
    
    // æµ‹è¯•PBKDF2
    PasswordHashResult result = PasswordHashCrypto.pbkdf2Hash(password);
    assertTrue(PasswordHashCrypto.verifyPBKDF2Password(password, result));
    assertFalse(PasswordHashCrypto.verifyPBKDF2Password("wrongPassword", result));
    
    // æµ‹è¯•BCrypt
    BCryptResult bcryptResult = PasswordHashCrypto.bcryptHash(password);
    assertTrue(PasswordHashCrypto.verifyBCryptPassword(password, bcryptResult.hash()));
    assertFalse(PasswordHashCrypto.verifyBCryptPassword("wrongPassword", bcryptResult.hash()));
}

@Test
public void testTimingAttackResistance() {
    String correctHash = "5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8";
    String wrongHash1 = "1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef";
    String wrongHash2 = "5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d9";
    
    // æµ‹è¯•æ¯”è¾ƒæ—¶é—´æ˜¯å¦ä¸€è‡´
    long start1 = System.nanoTime();
    CryptoUtils.secureEquals(correctHash.getBytes(), wrongHash1.getBytes());
    long time1 = System.nanoTime() - start1;
    
    long start2 = System.nanoTime();
    CryptoUtils.secureEquals(correctHash.getBytes(), wrongHash2.getBytes());
    long time2 = System.nanoTime() - start2;
    
    // æ—¶é—´å·®åº”è¯¥å¾ˆå°ï¼ˆå…è®¸ä¸€å®šè¯¯å·®ï¼‰
    long timeDiff = Math.abs(time1 - time2);
    assertTrue(timeDiff < 1000000); // 1ms
}
```

### 2. æ€§èƒ½åŸºå‡†æµ‹è¯•

```java
@Test
public void benchmarkHashingAlgorithms() {
    String testData = "This is a test message for benchmarking hash algorithms.";
    int iterations = 10000;
    
    // æµ‹è¯•SHA-256
    long start = System.currentTimeMillis();
    for (int i = 0; i < iterations; i++) {
        DigestCrypto.sha256(testData);
    }
    long sha256Time = System.currentTimeMillis() - start;
    
    // æµ‹è¯•SHA-512
    start = System.currentTimeMillis();
    for (int i = 0; i < iterations; i++) {
        DigestCrypto.sha512(testData);
    }
    long sha512Time = System.currentTimeMillis() - start;
    
    log.info("SHA-256: {}ms, SHA-512: {}ms", sha256Time, sha512Time);
}
```

### 3. é™æ€åˆ†æå·¥å…·

æ¨èä½¿ç”¨ä»¥ä¸‹å·¥å…·è¿›è¡Œå®‰å…¨åˆ†æï¼š

- **SpotBugs**: æ£€æµ‹å¸¸è§çš„å®‰å…¨æ¼æ´
- **SonarQube**: ä»£ç è´¨é‡å’Œå®‰å…¨åˆ†æ
- **Checkmarx**: ä¸“ä¸šçš„é™æ€å®‰å…¨æµ‹è¯•
- **Veracode**: åº”ç”¨å®‰å…¨æµ‹è¯•å¹³å°

```xml
<!-- Mavené…ç½®ç¤ºä¾‹ -->
<plugin>
    <groupId>com.github.spotbugs</groupId>
    <artifactId>spotbugs-maven-plugin</artifactId>
    <version>4.7.3.0</version>
    <configuration>
        <effort>Max</effort>
        <threshold>Low</threshold>
        <includeFilterFile>spotbugs-security-include.xml</includeFilterFile>
    </configuration>
</plugin>
```

## ğŸŒ åˆè§„æ€§ä¸æ ‡å‡†

### 1. æ ‡å‡†éµå¾ª

**FIPS 140-2**:
- ç¾å›½è”é‚¦ä¿¡æ¯å¤„ç†æ ‡å‡†
- å®šä¹‰äº†å¯†ç å­¦æ¨¡å—çš„å®‰å…¨è¦æ±‚
- åˆ†ä¸º4ä¸ªå®‰å…¨çº§åˆ«

**Common Criteria**:
- å›½é™…ä¿¡æ¯å®‰å…¨è¯„ä¼°æ ‡å‡†
- æä¾›å®‰å…¨åŠŸèƒ½å’Œä¿è¯è¦æ±‚

**NISTæ¨è**:
```java
// NIST SP 800-108æ¨èçš„å¯†é’¥æ´¾ç”Ÿ
public static byte[] kdf(byte[] ki, byte[] label, byte[] context, int dkLen) {
    // å®ç°åŸºäºHMACçš„å¯†é’¥æ´¾ç”Ÿå‡½æ•°
    // ...
}
```

### 2. è¡Œä¸šæœ€ä½³å®è·µ

**OWASPå¯†ç å­˜å‚¨å¤‡å¿˜å•**:
- ä½¿ç”¨é€‚å½“çš„å¯†ç å“ˆå¸Œç®—æ³•ï¼ˆPBKDF2ã€BCryptã€Argon2ï¼‰
- å®æ–½é€‚å½“çš„å·¥ä½œå› å­
- ä½¿ç”¨å¯†ç å­¦å®‰å…¨çš„ç›å€¼
- è€ƒè™‘å‡çº§ç­–ç•¥

**PCI DSSè¦æ±‚**:
- å¼ºåŠ å¯†ç®—æ³•ï¼ˆAES-256ã€RSA-2048+ï¼‰
- å®‰å…¨çš„å¯†é’¥ç®¡ç†
- å®šæœŸå¯†é’¥è½®æ¢

## ğŸ”® æœªæ¥å‘å±•æ–¹å‘

### 1. åé‡å­å¯†ç å­¦

**NISTæ ‡å‡†åŒ–ç®—æ³•**:
- **Kyber**: å¯†é’¥å°è£…æœºåˆ¶
- **Dilithium**: æ•°å­—ç­¾å
- **SPHINCS+**: æ— çŠ¶æ€ç­¾å

```java
// æœªæ¥çš„åé‡å­APIç¤ºä¾‹
public class PostQuantumCrypto {
    
    public static KyberKeyPair generateKyberKeyPair() {
        // Kyberå¯†é’¥ç”Ÿæˆ
    }
    
    public static byte[] kyberEncrypt(byte[] data, KyberPublicKey publicKey) {
        // KyberåŠ å¯†
    }
    
    public static DilithiumSignature dilithiumSign(byte[] data, DilithiumPrivateKey privateKey) {
        // Dilithiumç­¾å
    }
}
```

### 2. ç¡¬ä»¶å®‰å…¨æ¨¡å—é›†æˆ

```java
public class HSMIntegration {
    
    public static byte[] generateKeyInHSM(String keyId) {
        // åœ¨HSMä¸­ç”Ÿæˆå¯†é’¥
    }
    
    public static byte[] signWithHSM(byte[] data, String keyId) {
        // ä½¿ç”¨HSMè¿›è¡Œç­¾å
    }
}
```

### 3. é›¶çŸ¥è¯†è¯æ˜

```java
public class ZeroKnowledgeProof {
    
    public static ZKProof generateProof(String secret, String statement) {
        // ç”Ÿæˆé›¶çŸ¥è¯†è¯æ˜
    }
    
    public static boolean verifyProof(ZKProof proof, String statement) {
        // éªŒè¯é›¶çŸ¥è¯†è¯æ˜
    }
}
```

## ğŸ“ æ€»ç»“

å¯†ç å­¦å®‰å…¨æ˜¯ä¸€ä¸ªå¤æ‚è€Œé‡è¦çš„é¢†åŸŸï¼Œæœ¬æ–‡æ·±å…¥æ¢è®¨äº†ä»¥ä¸‹å…³é”®è¦ç‚¹ï¼š

### æŠ€æœ¯æ€»ç»“
1. **å“ˆå¸Œç®—æ³•**: é€‰æ‹©SHA-256+ï¼Œé¿å…MD5/SHA-1
2. **å¯†ç å­˜å‚¨**: ä½¿ç”¨PBKDF2/BCrypt/Argon2ï¼Œåˆé€‚çš„å·¥ä½œå› å­
3. **æ•°å­—ç­¾å**: æ ‡å‡†APIä¼˜äºè‡ªå®ç°ï¼Œè€ƒè™‘ECDSAæ€§èƒ½ä¼˜åŠ¿
4. **å®‰å…¨å®è·µ**: å¯†é’¥ç®¡ç†ã€éšæœºæ•°ç”Ÿæˆã€å†…å­˜å®‰å…¨

### å®æ–½å»ºè®®
1. **å¼€å‘é˜¶æ®µ**: ä½¿ç”¨å®‰å…¨ç¼–ç è§„èŒƒï¼Œå®æ–½ä»£ç å®¡æŸ¥
2. **æµ‹è¯•é˜¶æ®µ**: åŒ…å«å®‰å…¨æµ‹è¯•ï¼Œæ€§èƒ½åŸºå‡†æµ‹è¯•
3. **éƒ¨ç½²é˜¶æ®µ**: å®‰å…¨é…ç½®ï¼Œç›‘æ§å¼‚å¸¸è¡Œä¸º
4. **ç»´æŠ¤é˜¶æ®µ**: å®šæœŸæ›´æ–°ï¼Œå¯†é’¥è½®æ¢

### åˆè§„è€ƒè™‘
1. **æ ‡å‡†éµå¾ª**: FIPSã€Common Criteriaã€NISTæŒ‡å—
2. **è¡Œä¸šè¦æ±‚**: OWASPã€PCI DSSç­‰
3. **æ³•è§„éµä»**: GDPRã€SOXã€HIPAAç­‰

---

> ğŸ“– **ç³»åˆ—æ–‡ç« **:  
> - [ç°ä»£JavaåŠ å¯†ç®—æ³•å®æˆ˜æŒ‡å—ï¼šä»AESåˆ°RSAçš„å®Œæ•´å®ç°](./01-ç°ä»£JavaåŠ å¯†ç®—æ³•å®æˆ˜æŒ‡å—.md)  
> - [Javaç¼–ç è½¬æ¢æŠ€æœ¯å…¨è§£æï¼šBase64ã€URLç¼–ç ä¸è¿›åˆ¶è½¬æ¢](./02-Javaç¼–ç è½¬æ¢æŠ€æœ¯å…¨è§£æ.md)  

> ğŸ’» **é¡¹ç›®æºç **: [java-encryption](https://github.com/Rise1024/Java-Labs/tree/main/java-encryption#readme)  
> ğŸ’¬ **æŠ€æœ¯äº¤æµ**: [ä¸œå‡çš„æŠ€æœ¯åšå®¢](https://dongsheng.online)

---
